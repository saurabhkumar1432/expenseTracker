#!/bin/bash
# Pre-commit hook to prevent committing secrets and sensitive files
# Install: git config core.hooksPath .githooks

set -e

echo "ğŸ”’ Running security pre-commit checks..."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

ERRORS_FOUND=0

# =============================================================================
# Check 1: Prevent committing sensitive file types
# =============================================================================
echo "ğŸ“ Checking for sensitive files..."

SENSITIVE_PATTERNS=(
    '\.jks$'
    '\.keystore$'
    '\.p12$'
    '\.pem$'
    '\.key$'
    'google-services\.json$'
    'play-store-credentials\.json$'
    'service-account.*\.json$'
    'local\.properties$'
    '\.env$'
    '\.env\.'
)

for pattern in "${SENSITIVE_PATTERNS[@]}"; do
    if git diff --cached --name-only | grep -qE "$pattern"; then
        echo -e "${RED}âŒ ERROR: Attempting to commit sensitive file matching: $pattern${NC}"
        git diff --cached --name-only | grep -E "$pattern"
        ERRORS_FOUND=1
    fi
done

# =============================================================================
# Check 2: Scan staged files for potential secrets
# =============================================================================
echo "ğŸ” Scanning for hardcoded secrets..."

SECRET_PATTERNS=(
    # API Keys
    'api[_-]?key\s*[:=]\s*["\047][A-Za-z0-9_\-]{20,}["\047]'
    'apikey\s*[:=]\s*["\047][A-Za-z0-9_\-]{20,}["\047]'
    
    # AWS
    'AKIA[0-9A-Z]{16}'
    'aws[_-]?secret[_-]?access[_-]?key'
    
    # Google
    'AIza[0-9A-Za-z\-_]{35}'
    
    # Firebase
    'firebase[_-]?api[_-]?key'
    
    # Generic secrets
    'password\s*[:=]\s*["\047][^"\047]{8,}["\047]'
    'secret\s*[:=]\s*["\047][^"\047]{8,}["\047]'
    'token\s*[:=]\s*["\047][A-Za-z0-9_\-]{20,}["\047]'
    
    # Private keys
    '-----BEGIN (RSA |DSA |EC |OPENSSH )?PRIVATE KEY-----'
    '-----BEGIN CERTIFICATE-----'
    
    # Android signing
    'storePassword\s*=\s*["\047][^"\047]+["\047]'
    'keyPassword\s*=\s*["\047][^"\047]+["\047]'
    'storeFile\s*=\s*file\s*\(["\047][^"\047]+\.jks["\047]\)'
)

# Get list of staged files (excluding deleted files and binary files)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(kt|java|xml|json|yml|yaml|properties|gradle|gradle\.kts|rb|sh|md)$' || true)

if [ -n "$STAGED_FILES" ]; then
    for pattern in "${SECRET_PATTERNS[@]}"; do
        # Use git show to get staged content
        MATCHES=$(echo "$STAGED_FILES" | xargs -I {} sh -c 'git show ":{}' 2>/dev/null | grep -iE "$pattern" || true)
        if [ -n "$MATCHES" ]; then
            echo -e "${RED}âŒ ERROR: Potential secret found matching pattern: $pattern${NC}"
            echo "$MATCHES" | head -5
            ERRORS_FOUND=1
        fi
    done
fi

# =============================================================================
# Check 3: Verify .gitignore entries exist
# =============================================================================
echo "ğŸ“‹ Verifying .gitignore configuration..."

REQUIRED_IGNORES=(
    "local.properties"
    "*.jks"
    "*.keystore"
    "google-services.json"
)

if [ -f ".gitignore" ]; then
    for ignore in "${REQUIRED_IGNORES[@]}"; do
        if ! grep -qF "$ignore" .gitignore; then
            echo -e "${YELLOW}âš ï¸  WARNING: '$ignore' not found in .gitignore${NC}"
        fi
    done
else
    echo -e "${YELLOW}âš ï¸  WARNING: No .gitignore file found${NC}"
fi

# =============================================================================
# Final result
# =============================================================================
if [ $ERRORS_FOUND -eq 1 ]; then
    echo ""
    echo -e "${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${RED}â•‘  COMMIT BLOCKED: Potential secrets or sensitive files!     â•‘${NC}"
    echo -e "${RED}â•‘                                                            â•‘${NC}"
    echo -e "${RED}â•‘  If this is a false positive, you can bypass with:         â•‘${NC}"
    echo -e "${RED}â•‘  git commit --no-verify                                    â•‘${NC}"
    echo -e "${RED}â•‘                                                            â•‘${NC}"
    echo -e "${RED}â•‘  âš ï¸  Only bypass if you're CERTAIN it's safe!              â•‘${NC}"
    echo -e "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    exit 1
fi

echo -e "${GREEN}âœ… Security checks passed!${NC}"
exit 0
